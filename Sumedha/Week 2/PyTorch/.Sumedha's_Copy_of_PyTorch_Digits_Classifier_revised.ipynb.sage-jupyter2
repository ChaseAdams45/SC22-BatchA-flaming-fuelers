{"backend_state":"init","connection_file":"/projects/ce3fe429-16e9-4628-b009-0bb7ec5ec0d7/.local/share/jupyter/runtime/kernel-84c74bab-eede-40af-bfcc-4c3db82ce55d.json","kernel":"cv_env","kernel_error":"","kernel_state":"idle","kernel_usage":{"cpu":0,"memory":0},"metadata":{"accelerator":"GPU","colab":{"collapsed_sections":[],"name":"Digits_Classifier.ipynb","provenance":[]},"language_info":{"codemirror_mode":{"name":"ipython","version":3},"file_extension":".py","mimetype":"text/x-python","name":"python","nbconvert_exporter":"python","pygments_lexer":"ipython3","version":"3.8.13"}},"trust":true,"type":"settings"}
{"cell_type":"code","exec_count":0,"id":"cda7aa","input":"","pos":31,"type":"cell"}
{"cell_type":"code","exec_count":1,"id":"918dbd","input":"import random\nimport torch\nimport torchvision\nimport matplotlib.pyplot as plt","metadata":{"id":"LtoR_ZZwuDQj"},"pos":3,"type":"cell"}
{"cell_type":"code","exec_count":11,"id":"647e4e","input":"correct = 0\ntotal = 0\n# since we're not training, we don't need to calculate the gradients for our outputs\nwith torch.no_grad():\n    for images, labels in valloader:\n        #EXERCISE: Transfer the inputs and labels to the GPU\n        #EXERCISE: calculate outputs by running images through the network\n        images = images.view(images.shape[0], -1)\n        # calculate outputs by running images through the network\n        outputs = model(images)\n        # the class with the highest energy is what we choose as prediction\n        _, predicted = torch.max(outputs.data, 1)\n        total += labels.size(0)\n        correct += (predicted == labels).sum().item()\n\nprint(f'Accuracy of the network on the 10000 test images: {100 * correct // total} %')","metadata":{"colab":{"base_uri":"https://localhost:8080/"},"id":"Ppm0FK4xyJQR","outputId":"687c617f-975b-4636-f2e6-f3f321837f1b"},"output":{"0":{"name":"stdout","output_type":"stream","text":"Accuracy of the network on the 10000 test images: 96 %\n"}},"pos":25,"type":"cell"}
{"cell_type":"code","exec_count":14,"id":"a5773c","input":"# get and show a sample image\nimage = valset[0][0] # shape: [(1) batch_size, 28, 28]\nplt.subplot()\nplt.axis('off')\n# [1, 28, 28] -> [28, 28] - makes the image readable\nplt.imshow(image.squeeze(0))","metadata":{"colab":{"base_uri":"https://localhost:8080/","height":265},"id":"9CrgNFgI3xYt","outputId":"3b10d270-b394-4a36-f944-2b57006315cb"},"output":{"0":{"data":{"text/plain":"<matplotlib.image.AxesImage at 0x7f3060f0c5e0>"},"exec_count":14,"output_type":"execute_result"},"1":{"data":{"image/png":"0f7e39a34029b0ef035d89b6944b3de6d78ad3c6","text/plain":"<Figure size 432x288 with 1 Axes>"},"exec_count":14,"metadata":{"needs_background":"light"},"output_type":"execute_result"}},"pos":28,"type":"cell"}
{"cell_type":"code","exec_count":15,"id":"b485dd","input":"# [(1) batch_size, 28, 28]-> [1(batch size), 784]\nimage = image.view(1, 784)\nwith torch.no_grad():\n    # cast input to device\n    image = image.to(device)\n\n    log_preds = model(image) # runs the model\n\n# post processes the image into probabilities of it being each digit\n#   Math: probabilites were natural logged, so torch.exp() performs e^(log_preds)\npreds = torch.exp(log_preds)\nprobab = list(preds.cpu().numpy()[0])\n\n# the index, this time, is the same as the output, so we can just grab and print it\npred_label = probab.index(max(probab)) # get index of highest num (highest probability)\nprint(f\"Prediction: {pred_label}\")","metadata":{"colab":{"base_uri":"https://localhost:8080/"},"id":"2hxLIQGI6HHa","outputId":"53825ba4-27c7-424b-d6c9-63a7eccbdcf2"},"output":{"0":{"name":"stdout","output_type":"stream","text":"Prediction: 7\n"}},"pos":30,"type":"cell"}
{"cell_type":"code","exec_count":2,"id":"cc4633","input":"transform = torchvision.transforms.Compose([torchvision.transforms.ToTensor(),\n  torchvision.transforms.Normalize((0.5,), (0.5,)),\n])","metadata":{"id":"LSyJL6QIuJM4"},"pos":5,"type":"cell"}
{"cell_type":"code","exec_count":3,"id":"750468","input":"trainset = torchvision.datasets.MNIST('train_set', download=True, train=True, transform=transform) # downloads to train_set\nvalset = torchvision.datasets.MNIST('test_set', download=True, train=False, transform=transform) # downloads to test_set\ntrainloader = torch.utils.data.DataLoader(trainset, batch_size=64, shuffle=True) # batch is the number of images to consider at a time\nvalloader = torch.utils.data.DataLoader(valset, batch_size=64, shuffle=True)","metadata":{"id":"Q_fPpFanuNAa"},"pos":7,"scrolled":true,"type":"cell"}
{"cell_type":"code","exec_count":4,"id":"463d12","input":"for i in range(10):\n    rand_idx = random.randint(0, len(trainset)-1) # Pick an index for a random image\n    plt.subplot(2, 5, i+1) # 2 * 5 images in the grid, display 10 total\n    plt.axis('off')\n    # [1, 28, 28] -> [28, 28]\n    plt.imshow(trainset[rand_idx][0].squeeze(0))","metadata":{"colab":{"base_uri":"https://localhost:8080/","height":207},"id":"AwWg6nMm4gdg","outputId":"bfd04d34-6ca8-43bc-8830-e3978ec1316e"},"output":{"0":{"data":{"image/png":"92add50cc2d44a10b04a45c594614f9a98f9e8f9","text/plain":"<Figure size 432x288 with 10 Axes>"},"exec_count":4,"metadata":{"needs_background":"light"},"output_type":"execute_result"}},"pos":9,"type":"cell"}
{"cell_type":"code","exec_count":5,"id":"9b16b9","input":"input_size = 28 * 28 # width times height of the image (number of pixels)\nhidden_sizes = [128, 32] # this is the sizes of the hidden layers. The sizes are relativly arbitrary\nnum_class = 10 # one label for each digit (0-9)","metadata":{"id":"Bg20RWXHuW2W"},"pos":12,"type":"cell"}
{"cell_type":"code","exec_count":6,"id":"76936d","input":"device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")","metadata":{"id":"ATekqXGWxKBs"},"pos":14,"type":"cell"}
{"cell_type":"code","exec_count":7,"id":"5526c0","input":"model = torch.nn.Sequential(\n    # [(64) batch_size, (768) width x height] -> [(64) batch_size, (128) hidden_size #1]\n    torch.nn.Linear(input_size, hidden_sizes[0]),\n    torch.nn.ReLU(), # activation function\n    # [(64) batch_size, (128) hidden_size #1] -> [(64) batch_size, (32) hidden_size #2]\n    torch.nn.Linear(hidden_sizes[0], hidden_sizes[1]),\n    torch.nn.ReLU(), # activation function\n    # [(64) batch_size, (32) hidden_size #2] -> [(64) batch_size, (10) num_class]\n    torch.nn.Linear(hidden_sizes[1], num_class),\n    torch.nn.ReLU(), # activation function\n    #EXERCISE: Define the third layer as taking in the output size of the second layer and outputting the number of classes. \n\n    # output activation function - the hidden layer functions don't work for optimization\n    # LogSoftmax because it is better at gradient optimization\n    torch.nn.LogSoftmax(dim=-1) # apply LogSoftmax to the last layer (num_class)\n)","metadata":{"id":"iWS_Hzt-uhNP"},"pos":17,"type":"cell"}
{"cell_type":"code","exec_count":8,"id":"146757","input":"model.to(device)","metadata":{"colab":{"base_uri":"https://localhost:8080/"},"id":"zqtJo49FxLH-","outputId":"3b8bc56d-ab7f-4a57-da50-4eb6d2f4651e"},"output":{"0":{"data":{"text/plain":"Sequential(\n  (0): Linear(in_features=784, out_features=128, bias=True)\n  (1): ReLU()\n  (2): Linear(in_features=128, out_features=32, bias=True)\n  (3): ReLU()\n  (4): Linear(in_features=32, out_features=10, bias=True)\n  (5): ReLU()\n  (6): LogSoftmax(dim=-1)\n)"},"exec_count":8,"output_type":"execute_result"}},"pos":19,"type":"cell"}
{"cell_type":"code","exec_count":9,"id":"7eaf7f","input":"# Model training for 8 times\ncriterion = torch.nn.NLLLoss() # Loss object to find back propagation\noptimizer = torch.optim.SGD(model.parameters(), lr=0.003, momentum=0.9) # Optimizer\nepochs = 8\nfor e in range(epochs):\n    running_loss = 0\n    for images, labels in trainloader:\n        #EXERCISE: transfer images and labels to GPU. \n        images.to(device)\n        labels.to(device)\n        \n        # Formats the image to be a usable 1d array.\n        #   [(64) batch size, 1, 28, 28] -> [(64) batch size, 768]\n        images = images.view(images.shape[0], -1)\n        \n        # Resets the optimizer for each training step\n        optimizer.zero_grad()\n        \n        # Finds error then runs back propagation\n        output = model(images)\n        #EXERCISE: calculate the loss by passing the outputs and the labels into the loss function.\n        loss = criterion(output, labels)  \n        loss.backward()\n        \n        # Updates model weights\n        optimizer.step()\n        \n        # Keeps track of error to allow visualization of progress\n        running_loss += loss.item()\n    else:\n        print(\"Epoch {} - Training loss: {}\".format(e, running_loss/len(trainloader)))","metadata":{"colab":{"base_uri":"https://localhost:8080/"},"id":"s-B0laEkwlst","outputId":"b6c2fd03-4761-42fe-ad5f-7087096b3a88"},"output":{"0":{"name":"stdout","output_type":"stream","text":"Epoch 0 - Training loss: 0.9473364369224891\n"},"1":{"name":"stdout","output_type":"stream","text":"Epoch 1 - Training loss: 0.3020296254709585\n"},"2":{"name":"stdout","output_type":"stream","text":"Epoch 2 - Training loss: 0.2299021828744902\n"},"3":{"name":"stdout","output_type":"stream","text":"Epoch 3 - Training loss: 0.18392322501584665\n"},"4":{"name":"stdout","output_type":"stream","text":"Epoch 4 - Training loss: 0.15145991050374152\n"},"5":{"name":"stdout","output_type":"stream","text":"Epoch 5 - Training loss: 0.1310958799921961\n"},"6":{"name":"stdout","output_type":"stream","text":"Epoch 6 - Training loss: 0.11286420516594291\n"},"7":{"name":"stdout","output_type":"stream","text":"Epoch 7 - Training loss: 0.1006287435548249\n"}},"pos":23,"type":"cell"}
{"cell_type":"markdown","id":"0c2fac","input":"Got your own image to run prediction on?","metadata":{"id":"ffF-vY365-Dn"},"pos":27,"type":"cell"}
{"cell_type":"markdown","id":"1b95bf","input":"So torch.nn.Sequential pretty much compiles a group of layers into one network, and runs them sequentially for predictions. All of the layers that we are using for this are fully connected layers. The input size is 28 by 28 because we are flattening out the 28 by 28 image into 28*28=784 numbers. We are adding a activation function ReLU after that. ReLU(x) = max(x,0) so relu turns negative values to zero and positive values stay the same. \n\nAfter the first layer, we take the number of outputs of the first layer as the number of inputs into the second layer. And an arbitrary number of outputs for the second layer that we decide. \n\nNotice how we have an activation function after each layer. \n\nThen the third layer you code yourself, view the instructions below. \n\nFinally, we have an output activation function. The 10 numbers that are outputted from our previous layer can be any numbers from negative infinity to infinity. We want every class output to be from zero to one, like a probability. The softmax activation function turns the output into a probability for each class. \n\n","metadata":{"id":"QtFMastrDkvf"},"pos":16,"type":"cell"}
{"cell_type":"markdown","id":"1c2d5e","input":"<h1>Using the Model!</h1>\n\n","metadata":{"id":"FU9DtjN9Dkvm"},"pos":26,"type":"cell"}
{"cell_type":"markdown","id":"1d6e92","input":"GPU boost training time. Why? Because it lets us do many operations at the same time in a parallelized sort of way. \n\nCUDA is the API that we will use for GPU training. If CUDA is available we want to use it, and otherwise use the CPU. Google colab comes with a built in GPU for use so make sure to activate it by going to Runtime->Change runtime type->GPU","metadata":{"id":"E9WnnZwZxGWq"},"pos":13,"type":"cell"}
{"cell_type":"markdown","id":"21b39e","input":"<h1>Training the model</h1>","metadata":{"id":"N1UvEyWzDkvi"},"pos":20,"type":"cell"}
{"cell_type":"markdown","id":"228dc3","input":"NLLLoss docs - https://pytorch.org/docs/stable/generated/torch.nn.NLLLoss.html?highlight=nllloss#torch.nn.NLLLoss\nOptim docs - https://pytorch.org/docs/stable/optim.html","metadata":{"id":"wpYVqK89Dkvj"},"pos":22,"type":"cell"}
{"cell_type":"markdown","id":"37bea4","input":"Random is the default python library for generating random numbers.\n\nPyTorch, or torch, is the python deep learning library we use for our neural networks. \n\nTorchvision is for computer vision specific functions such as transforming images and image datasets. \n\nMatplotlib is used for graphing figures with data, whether it be scatterplots, heatmaps, lineplots, etc...","metadata":{"id":"kWiyySymuN07"},"pos":2,"type":"cell"}
{"cell_type":"markdown","id":"46a9d4","input":"<h1>Preprocessing our Images</h1>\n\nThe transform that we will perform on our dataset is first converting all images to tensors. Tensors are the built in array datatype in pytorch, like numpy arrays. If interested, learn about why they are useful in keeping track of gradients here:\nhttps://pytorch.org/tutorials/beginner/blitz/autograd_tutorial.html .\n\nConverting to a tensor also converts an image with pixel values from 0 to 255 to a matrix with numbers from 0 to 1. \n\nIn addition, we are normalizing the data to a range between -1 and 1. If the range before is [0,1], subtracting 0.5 will give us [-0.5,0.5] and dividing by 0.5 will make the range wider to [-1,1]. torch.Normalize subtracts the first parameter from all the values in the image and divides by the second parameter. \n\n","metadata":{"id":"m2tj_3PsuRkh"},"pos":4,"type":"cell"}
{"cell_type":"markdown","id":"4e0465","input":"## Hyperparameters\n\ndatasets docs - https://pytorch.org/vision/stable/datasets.html\n\nThe input size is the pixel size of the images, each of which is 28 by 28.\n\nThe number of classifcation (num_classes) is 10 because there are 10 possible classifications the model can make, such as 0, 1, 2 ... 9. \n\nThe hidden_sizes is the number of neurons in the hidden layer of the neural network. The input size and output sizes are always fixed (input size is related to number of pixels and output size is the number of classes) but the optimal hidden layer sizes can be determined only through experimentation. \n","metadata":{"id":"_xDFVY4muq_1"},"pos":11,"type":"cell"}
{"cell_type":"markdown","id":"6c0034","input":"# Classifying handwritten digits (0-9) with neural networks ","metadata":{"id":"LGtV5-Jc6zJz"},"pos":0,"type":"cell"}
{"cell_type":"markdown","id":"76aae8","input":"## Evaluation Loop\n\n&ensp; Iterate through every batch in the dataset<br>\n&ensp;&ensp; Get the prediction of every image in the batch<br>\n&ensp;&ensp; Add the number of images to the total<br>\n&ensp;&ensp; Add the number of correctly classified images to a counter<br>\n&ensp;&ensp; Get the accuracy through correct/total.<br>\n\n","metadata":{"id":"S_58fHPtDkvk"},"pos":24,"type":"cell"}
{"cell_type":"markdown","id":"80d58f","input":"## Visualization !!!\n\nFor 10 iterations, select a random index from zero to the length of the training dataset. Display each image in a 2 by 5 subplot as the 1st, 2nd, 3rd etc... image in the plot.","metadata":{"id":"0T4Y-JVy4WUy"},"pos":8,"type":"cell"}
{"cell_type":"markdown","id":"a1dc30","input":"<h1>Creating the Model</h1>","metadata":{"id":"pc8-Fbf4Dkvb"},"pos":10,"type":"cell"}
{"cell_type":"markdown","id":"bb603b","input":"Build a neural network in pytorch with two hidden layers","metadata":{"id":"hRpV2GTwvBYZ"},"pos":15,"type":"cell"}
{"cell_type":"markdown","id":"c15b9a","input":"We have to transfer the model to the GPU device. ","metadata":{"id":"wqegJQ24Dkvg"},"pos":18,"type":"cell"}
{"cell_type":"markdown","id":"cd5354","input":"# Applying the transforms\n\nWe are using the datasets.MNIST function from torchvision to import the dataset. \n\nParameters to the function:\n\nThe root parameter sets the directory that we import the data to (and create it if it doesn't exist.)\n\nThe train parameter determines if we are importing training or testing fashion MNIST dataset. \n\nThe transform parameter determines the transforms we apply during preprocessing, which were defined above.\n\ndownload=True gives the function permission to download the data into the directory if it doesn't exist there. \n\n","metadata":{"id":"MMEm9idPuYWq"},"pos":6,"type":"cell"}
{"cell_type":"markdown","id":"d29c60","input":"## Training our Model\n\nThe training process goes somewhat like this\ngo through the dataset [epoch] times<br>\n&ensp;  go through each image in the dataset<br>\n&ensp;&ensp; transfer inputs and labels to GPU<br>\n&ensp;&ensp; get prediction for input<br>\n&ensp;&ensp; check if prediction matches label, get loss<br>\n&ensp;&ensp; see which direction you have to change the weights<br>\n&ensp;&ensp; actually change weights using optimizer and learning rate\n&ensp;&ensp; Set the directions back to zero (optim.zero_grad())<br>\n&ensp;&ensp; add loss to total loss until reset<br>\n&ensp;&ensp; after some iterations, print out loss and reset\n\nFew more things to note. NLLLoss is the default loss function for softmax (probabilities that are far away from the true probabilities are penalized). ","metadata":{"id":"1HqqlulNwyqb"},"pos":21,"type":"cell"}
{"cell_type":"markdown","id":"e24825","input":"Run Prediction","metadata":{"id":"q2ZVmfom6XsO"},"pos":29,"type":"cell"}
{"cell_type":"markdown","id":"e4fbe7","input":"<h1>Getting Set Up</h1>","metadata":{"id":"KU8e-P7CDkvN"},"pos":1,"type":"cell"}
{"id":0,"time":1655237901187,"type":"user"}
{"last_load":1655237559901,"type":"file"}